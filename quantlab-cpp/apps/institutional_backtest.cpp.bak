#include <iostream>
#include <cstdlib>
#include <            // PROFESSIONAL MULTI-MINUTE DATA AGGREGATION SYSTEM: Extended Historical Analysis
            std::cout << "ðŸš€ PROFESSIONAL MULTI-MINUTE DATA AGGREGATION SYSTEM ACTIVATED" << std::endl;
            std::cout << "ðŸŽ¯ Target: 250 days (8+ months) of daily TSLA data" << std::endl;
            std::cout << "ðŸ’¡ Rate-limited across multiple minutes for maximum data collection!" << std::endl;
            std::cout << "â±ï¸  Estimated time: ~3 minutes for comprehensive institutional dataset" << std::endl;
            
            // Use professional multi-minute aggregated loading system: 250 days of comprehensive data
            strategy.load_aggregated_historical_data(test_symbol, "1Day", 250, 1);
#include <iomanip>
#include "../src/strategy/mean_reversion_strategy.hpp"
#include "../src/backtest/backtest_engine.hpp"

int main() {
    // Set environment variables
    setenv("ALPACA_API_KEY_ID", "PKIEMARS3MJXIO0CQ016", 1);
    setenv("ALPACA_API_SECRET_KEY", "OWd6nfpobGbHwvFbWqbEZSQDK187PEJtU0SKDk3f", 1);
    setenv("ALPACA_BASE_URL", "https://paper-api.alpaca.markets/v2", 1);
    
    // Focus on TSLA only for comprehensive backtesting
    std::string test_symbol = "TSLA";
    
    try {
        std::cout << "ðŸ›ï¸ INSTITUTIONAL TSLA BACKTESTING SYSTEM ðŸ›ï¸" << std::endl;
        std::cout << std::string(70, '=') << std::endl;
        std::cout << "Professional-grade TSLA backtesting with 1000 hourly bars" << std::endl;
        std::cout << "Strategy: Mean Reversion with Institutional Confidence" << std::endl;
        std::cout << "Timeframe: 1000 hours (~40+ trading days of comprehensive data)" << std::endl;
        
        // Initialize market data client
        quantlab::data::AlpacaClient client;
        
        std::cout << "\nðŸ”Œ Establishing market data connection..." << std::endl;
        if (!client.test_connection()) {
            std::cout << "âŒ Market data connection failed!" << std::endl;
            return 1;
        }
        std::cout << "âœ… Connected to institutional market data feed!" << std::endl;
        
        std::cout << "\n" << std::string(70, '=') << std::endl;
        std::cout << "ðŸ“Š COMPREHENSIVE TSLA ANALYSIS" << std::endl;
        std::cout << std::string(70, '=') << std::endl;
        
        try {
            // Initialize professional mean reversion strategy
            quantlab::strategy::MeanReversionStrategy strategy(
                12,     // EMA period - institutional standard
                14,     // RSI period - widely used professional setting
                20,     // Bollinger Bands period - institutional standard
                2.0,    // BB standard deviation - professional risk level
                &client, // Market data client
                30,     // RSI oversold threshold - conservative
                70      // RSI overbought threshold - conservative
            );
            
            // MULTI-CALL DATA AGGREGATION SYSTEM: Overcome 15-bar API limitation
            std::cout << "ï¿½ MULTI-CALL DATA AGGREGATION SYSTEM ACTIVATED" << std::endl;
            std::cout << "ðŸŽ¯ Target: 60 days of daily TSLA data through 4Ã—15 day API calls" << std::endl;
            std::cout << "ðŸ’¡ This will give us 4x more data than the API limit!" << std::endl;
            
            // Use new aggregated loading system: 60 days through 4 calls of 15 days each
            strategy.load_aggregated_historical_data(test_symbol, "1Day", 60, 15);
            
            // Get current price for context
            double current_price = client.get_latest_price(test_symbol);
            std::cout << "ðŸ’° Current TSLA price: $" << std::fixed << std::setprecision(2) << current_price << std::endl;
            
            // Initialize backtesting engine with institutional capital
            quantlab::backtest::BacktestEngine backtest_engine(1000000.0);  // $1M starting capital
            auto& portfolio = backtest_engine.get_portfolio();
            
            // Run comprehensive backtest
            std::cout << "âš¡ Running comprehensive TSLA backtest..." << std::endl;
            std::cout << "   Processing historical data points..." << std::endl;
            
            auto backtest_results = strategy.backtest();
            
            if (backtest_results.empty()) {
                std::cout << "âš ï¸ No backtest data available for TSLA" << std::endl;
                return 1;
            }
            
            std::cout << "âœ… Processed " << backtest_results.size() << " data points!" << std::endl;
            
            // FIXED: Keep the best results instead of overwriting with failed fallbacks
            auto best_results = backtest_results;  // Save our good aggregated results
            
            if (backtest_results.size() < 30) {
                std::cout << "âš ï¸ Multi-call aggregation returned " << backtest_results.size() << " bars." << std::endl;
                std::cout << "ðŸ”„ Trying fallback to hourly data approach..." << std::endl;
                
                // Try fallback but only use if better
                strategy.load_historical_data(test_symbol, "1Hour", 1000);
                auto hourly_results = strategy.backtest();
                std::cout << "âœ… Hourly fallback: " << hourly_results.size() << " data points!" << std::endl;
                
                // Only use hourly results if they're significantly better
                if (hourly_results.size() > backtest_results.size() * 2) {
                    backtest_results = hourly_results;
                    std::cout << "ðŸ“ˆ Using hourly data (much better coverage)" << std::endl;
                } else {
                    std::cout << "ðŸ“Š Keeping aggregated data (better quality)" << std::endl;
                }
                
                // Final attempt only if we still have very few results
                if (backtest_results.size() < 10) {
                    std::cout << "ðŸ”„ Final attempt: 1Hour timeframe with 1500 bars..." << std::endl;
                    strategy.load_historical_data(test_symbol, "1Hour", 1500);
                    auto final_results = strategy.backtest();
                    std::cout << "âœ… Final attempt: " << final_results.size() << " data points!" << std::endl;
                    
                    if (final_results.size() > backtest_results.size()) {
                        backtest_results = final_results;
                    }
                }
            }
            
            std::cout << "ðŸ’¼ Executing institutional-grade trades..." << std::endl;
            bool position_open = false;
            int base_position_size = std::max(100, (int)(50000 / current_price));  // $50K base position
            int trades_executed = 0;
            double max_confidence_seen = 0.0;
            int high_confidence_signals = 0;
            int total_signals = 0;
            
            for (const auto& result : backtest_results) {
                // Track portfolio value
                double portfolio_value = portfolio.get_total_value(result.current_price);
                portfolio.daily_values.push_back(portfolio_value);
                
                // Track confidence statistics
                max_confidence_seen = std::max(max_confidence_seen, result.confidence);
                
                if (result.signal != quantlab::strategy::Signal::HOLD) {
                    total_signals++;
                    if (result.confidence >= 0.65) high_confidence_signals++;
                }
                
                // Execute BUY signals with 65% confidence threshold
                if (result.signal == quantlab::strategy::Signal::BUY && !position_open && result.confidence >= 0.65) {
                    if (portfolio.can_buy(result.current_price, base_position_size)) {
                        portfolio.execute_buy(result.current_price, base_position_size, result.confidence, result.reason);
                        position_open = true;
                        trades_executed++;
                        
                        std::cout << "ðŸŸ¢ BUY TSLA: " << base_position_size 
                                  << " shares @ $" << std::fixed << std::setprecision(2) << result.current_price 
                                  << " (Confidence: " << (int)(result.confidence*100) << "%)" << std::endl;
                        std::cout << "   ðŸ“‹ Reason: " << result.reason << std::endl;
                    }
                }
                // Execute SELL signals with 65% confidence threshold
                else if (result.signal == quantlab::strategy::Signal::SELL && position_open && result.confidence >= 0.65) {
                    if (portfolio.shares_held > 0) {
                        int sell_shares = std::min(portfolio.shares_held, base_position_size);
                        portfolio.execute_sell(result.current_price, sell_shares, result.confidence, result.reason);
                        
                        if (portfolio.shares_held == 0) {
                            position_open = false;
                        }
                        trades_executed++;
                        
                        std::cout << "ðŸ”´ SELL TSLA: " << sell_shares 
                                  << " shares @ $" << std::fixed << std::setprecision(2) << result.current_price 
                                  << " (Confidence: " << (int)(result.confidence*100) << "%)" << std::endl;
                        std::cout << "   ðŸ“‹ Reason: " << result.reason << std::endl;
                    }
                }
            }
            
            // Close any remaining position at current price
            if (position_open && portfolio.shares_held > 0) {
                portfolio.execute_sell(current_price, portfolio.shares_held, 0.5, "End of backtest period");
                std::cout << "ðŸ”„ CLOSING FINAL POSITION: " << portfolio.shares_held 
                          << " shares @ $" << std::fixed << std::setprecision(2) << current_price << std::endl;
            }
            
            // Calculate comprehensive metrics
            backtest_engine.calculate_final_metrics(current_price);
            const auto& metrics = backtest_engine.get_metrics();
            
            // Display detailed results
            std::cout << "\nðŸ“Š COMPREHENSIVE TSLA BACKTEST RESULTS" << std::endl;
            std::cout << std::string(60, '-') << std::endl;
            
            std::cout << "\nðŸ’° PORTFOLIO PERFORMANCE:" << std::endl;
            std::cout << "Starting Capital: $" << std::fixed << std::setprecision(0) << metrics.starting_capital << std::endl;
            std::cout << "Ending Capital:   $" << std::fixed << std::setprecision(0) << metrics.ending_capital << std::endl;
            std::cout << "Total Return:     " << std::fixed << std::setprecision(2) << metrics.total_return_pct << "%" << std::endl;
            
            if (metrics.total_return_pct > 5.0) {
                std::cout << "ðŸš€ EXCELLENT PERFORMANCE!" << std::endl;
            } else if (metrics.total_return_pct > 0) {
                std::cout << "âœ… PROFITABLE STRATEGY" << std::endl;
            } else if (metrics.total_return_pct == 0) {
                std::cout << "â­• BREAK-EVEN RESULT" << std::endl;
            } else {
                std::cout << "âŒ UNDERPERFORMING STRATEGY" << std::endl;
            }
            
            std::cout << "\nâš ï¸ RISK METRICS:" << std::endl;
            std::cout << "Max Drawdown:     " << std::fixed << std::setprecision(2) << metrics.max_drawdown_pct << "%" << std::endl;
            std::cout << "Sharpe Ratio:     " << std::fixed << std::setprecision(2) << metrics.sharpe_ratio << std::endl;
            
            std::cout << "\nðŸ“ˆ TRADE ANALYSIS:" << std::endl;
            std::cout << "Data Points:      " << backtest_results.size() << std::endl;
            std::cout << "Total Signals:    " << total_signals << std::endl;  
            std::cout << "High Conf (65%+): " << high_confidence_signals << std::endl;
            std::cout << "Trades Executed:  " << trades_executed << std::endl;
            std::cout << "Winning Trades:   " << metrics.winning_trades << std::endl;
            std::cout << "Losing Trades:    " << metrics.losing_trades << std::endl;
            std::cout << "Win Rate:         " << std::fixed << std::setprecision(1) << metrics.win_rate_pct << "%" << std::endl;
            std::cout << "Max Confidence:   " << std::fixed << std::setprecision(1) << (max_confidence_seen*100) << "%" << std::endl;
            
            if (metrics.winning_trades > 0) {
                std::cout << "Average Win:      $" << std::fixed << std::setprecision(0) << metrics.avg_win << std::endl;
            }
            if (metrics.losing_trades > 0) {
                std::cout << "Average Loss:     $" << std::fixed << std::setprecision(0) << metrics.avg_loss << std::endl;
                std::cout << "Profit Factor:    " << std::fixed << std::setprecision(2) << metrics.profit_factor << std::endl;
            }
            
            std::cout << "\nðŸ§  ANALYSIS INSIGHTS:" << std::endl;
            std::cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << std::endl;
            std::cout << "ðŸ“Š Processed " << backtest_results.size() << " hourly TSLA bars" << std::endl;
            std::cout << "ðŸŽ¯ Professional 65% confidence threshold maintained" << std::endl;
            std::cout << "ðŸ’¼ Institutional $1M starting capital" << std::endl;
            std::cout << "ðŸ“ˆ Hourly timeframe analysis (1000+ hours of data)" << std::endl;
            std::cout << "ðŸ›ï¸ This represents comprehensive institutional trading analysis!" << std::endl;
            
        } catch (const std::exception& e) {
            std::cout << "âŒ Error testing TSLA: " << e.what() << std::endl;
            return 1;
        }
        
        std::cout << "\nðŸŽ‰ TSLA INSTITUTIONAL BACKTESTING COMPLETE!" << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "âŒ System Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}